import random
from collections import Counter, defaultdict
from statistics import mean, stdev

import scipy.stats as stats

__all__ = ["flow_null", "all_flows_null"]


def _generate_random_branch(reference, size):
    """
    Generate a random branch of a given size by sampling elements from the reference partition.
    """
    elems = list()
    for subset in reference:
        elems.extend(subset)
    return random.sample(elems, size)


def _null_model(branch, reference, iterations):
    """
    Generate a null model for a given branch by generating num_permutations random branches of the same size and
    computing the mean and standard deviation of the frequency of each element in the reference partition.
    """
    null_branch = defaultdict(list)
    for _ in range(iterations):
        random_branch = _generate_random_branch(reference, len(branch))
        count = Counter(random_branch)
        for name, frequency in count.items():
            null_branch[name].append(frequency)

    avg_null_branch = defaultdict(dict)
    for name, frequencies in null_branch.items():
        if len(frequencies) == 1:
            avg_null_branch[name]["mean"] = frequencies[0]
            avg_null_branch[name]["std"] = 0
        else:
            avg_null_branch[name]["mean"] = mean(frequencies)
            avg_null_branch[name]["std"] = stdev(frequencies)

    return dict(avg_null_branch)


def _p_value(size, null_model):
    """
    Compute the p-value of a branch given a null model via z-score
    """

    z = (size - null_model["mean"]) / (
        null_model["std"] + 1e-6
    )  # 1e-6 to avoid division by zero
    p = stats.norm.sf(abs(z))

    return p


def flow_null(
    lc: object,
    target: str,
    direction: str,
    min_branch_size: int = 1,
    iterations: int = 1000,
) -> dict:
    """
    Compare the flow with a null model. Each branch of each flow is compared with a null branch of the same size.
    The null model is generated by randomly sampling elements from the reference partition *iterations* times.
    The mean and standard deviation of the null model are used to compute a z-score
    for each branch, which is then used to compute a p-value.

    :param lc: a CommunityMatching object
    :param target: target set identifier
    :param direction: temporal direction
    :param min_branch_size: minimum size of a branch to be considered
    :param iterations: number of random draws to be used to generate the null model
    :return: a dictionary keyed by set identifier and valued by mean, std, and p-value

    :Example:

    >>> from cdlib import TemporalClustering, LifeCycle
    >>> from cdlib import algorithms
    >>> from cdlib.lifecycles.algorithms import flow_null
    >>> from networkx.generators.community import LFR_benchmark_graph
    >>> tc = TemporalClustering()
    >>> for t in range(0, 10):
    >>>     g = LFR_benchmark_graph(
    >>>         n=250,
    >>>         tau1=3,
    >>>         tau2=1.5,
    >>>         mu=0.1,
    >>>         average_degree=5,
    >>>         min_community=20,
    >>>         seed=10,
    >>>     )
    >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
    >>>     tc.add_clustering(coms, t)
    >>> events = LifeCycle(tc)
    >>> events.compute_events("facets")
    >>> validated = flow_null(events, "0_2", "+")

    """

    flow = lc.group_flow(target, direction, min_branch_size)
    tid = int(target.split("_")[0])
    if direction == "+":
        tid += 1
    elif direction == "-":
        tid -= 1
    else:
        raise ValueError(f"Invalid direction: {direction}")
    # convert to list of ids lists
    reference = [[id_] * len(lc.get_group(id_)) for id_ in lc.get_partition_at(tid)]

    validated = dict()
    for name, subset in flow.items():
        null_model = _null_model(subset, reference, iterations)[name]
        # mull mean, null std, p-value
        validated[name] = {
            "mean": null_model["mean"],
            "std": null_model["std"],
            "p-value": _p_value(len(subset), null_model),
        }
    return validated


def all_flows_null(
    lc: object,
    direction: str,
    min_branch_size=1,
    iterations=1000,
):
    """
    Compare all flows with null models. See validate_flow for details.

    :param lc: a CommunityOMatching object
    :param direction: temporal direction
    :param min_branch_size: minimum size of a branch to be considered
    :param iterations: number of random draws to be used to generate the null model
    :return: a dictionary keyed by set identifier and valued by mean, std, and p-value

    :Example:

    >>> from cdlib import TemporalClustering, LifeCycle
    >>> from cdlib import algorithms
    >>> from cdlib.lifecycles.algorithms import all_flows_null
    >>> from networkx.generators.community import LFR_benchmark_graph
    >>> tc = TemporalClustering()
    >>> for t in range(0, 10):
    >>>     g = LFR_benchmark_graph(
    >>>         n=250,
    >>>         tau1=3,
    >>>         tau2=1.5,
    >>>         mu=0.1,
    >>>         average_degree=5,
    >>>         min_community=20,
    >>>         seed=10,
    >>>     )
    >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
    >>>     tc.add_clustering(coms, t)
    >>> events = LifeCycle(tc)
    >>> events.compute_events("facets")
    >>> validated = all_flows_null(events, "+")

    """
    validated = dict()
    for target, flow in lc.all_flows(direction, min_branch_size).items():
        validated[target] = flow_null(
            lc, target, direction, min_branch_size, iterations
        )
    return validated
